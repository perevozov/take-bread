// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addToList = `-- name: AddToList :one
INSERT 
INTO item_list (list_id, item_id, position) 
VALUES ($1, $2, $3) RETURNING list_id, item_id, position
`

type AddToListParams struct {
	ListID   uuid.UUID
	ItemID   uuid.UUID
	Position sql.NullInt32
}

func (q *Queries) AddToList(ctx context.Context, arg AddToListParams) (ItemList, error) {
	row := q.db.QueryRowContext(ctx, addToList, arg.ListID, arg.ItemID, arg.Position)
	var i ItemList
	err := row.Scan(&i.ListID, &i.ItemID, &i.Position)
	return i, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (title) VALUES ($1) RETURNING id, title, date_create
`

func (q *Queries) CreateItem(ctx context.Context, title string) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem, title)
	var i Item
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}

const createItemWithId = `-- name: CreateItemWithId :one
INSERT INTO items (id, title) VALUES ($1, $2) RETURNING id, title, date_create
`

type CreateItemWithIdParams struct {
	ID    uuid.UUID
	Title string
}

func (q *Queries) CreateItemWithId(ctx context.Context, arg CreateItemWithIdParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItemWithId, arg.ID, arg.Title)
	var i Item
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}

const createList = `-- name: CreateList :one
INSERT INTO lists (
  title
) VALUES (
  $1
)
RETURNING id, title, date_create
`

func (q *Queries) CreateList(ctx context.Context, title string) (List, error) {
	row := q.db.QueryRowContext(ctx, createList, title)
	var i List
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}

const deleteItem = `-- name: DeleteItem :exec
DELETE FROM items WHERE id = $1
`

func (q *Queries) DeleteItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteItem, id)
	return err
}

const getItem = `-- name: GetItem :one
SELECT id, title, date_create FROM items WHERE id = $1 LIMIT 1
`

func (q *Queries) GetItem(ctx context.Context, id uuid.UUID) (Item, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i Item
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}

const getList = `-- name: GetList :one
SELECT id, title, date_create FROM lists WHERE id=$1
`

func (q *Queries) GetList(ctx context.Context, id uuid.UUID) (List, error) {
	row := q.db.QueryRowContext(ctx, getList, id)
	var i List
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}

const listItems = `-- name: ListItems :many
SELECT id, title, date_create FROM items
`

func (q *Queries) ListItems(ctx context.Context) ([]Item, error) {
	rows, err := q.db.QueryContext(ctx, listItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(&i.ID, &i.Title, &i.DateCreate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsByList = `-- name: ListItemsByList :many
SELECT 
i.id, i.title, i.date_create,
il.position
FROM 
    item_list il
    INNER JOIN items i on i.id=il.item_id
WHERE il.list_id=$1
ORDER BY il.position asc
`

type ListItemsByListRow struct {
	ID         uuid.UUID
	Title      string
	DateCreate time.Time
	Position   sql.NullInt32
}

func (q *Queries) ListItemsByList(ctx context.Context, listID uuid.UUID) ([]ListItemsByListRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemsByList, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsByListRow
	for rows.Next() {
		var i ListItemsByListRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.DateCreate,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLists = `-- name: ListLists :many
SELECT id, title, date_create FROM lists ORDER BY date_create desc
`

func (q *Queries) ListLists(ctx context.Context) ([]List, error) {
	rows, err := q.db.QueryContext(ctx, listLists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(&i.ID, &i.Title, &i.DateCreate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllFromList = `-- name: RemoveAllFromList :exec
DELETE FROM item_list WHERE list_id=$1
`

func (q *Queries) RemoveAllFromList(ctx context.Context, listID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeAllFromList, listID)
	return err
}

const removeFromList = `-- name: RemoveFromList :exec
DELETE FROM item_list WHERE list_id=$1 and item_id=$2
`

type RemoveFromListParams struct {
	ListID uuid.UUID
	ItemID uuid.UUID
}

func (q *Queries) RemoveFromList(ctx context.Context, arg RemoveFromListParams) error {
	_, err := q.db.ExecContext(ctx, removeFromList, arg.ListID, arg.ItemID)
	return err
}

const updateItem = `-- name: UpdateItem :one
UPDATE items SET title=$2 WHERE id=$1 RETURNING id, title, date_create
`

type UpdateItemParams struct {
	ID    uuid.UUID
	Title string
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, updateItem, arg.ID, arg.Title)
	var i Item
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}

const updateList = `-- name: UpdateList :one
UPDATE lists SET title=$2 WHERE id=$1 RETURNING id, title, date_create
`

type UpdateListParams struct {
	ID    uuid.UUID
	Title string
}

func (q *Queries) UpdateList(ctx context.Context, arg UpdateListParams) (List, error) {
	row := q.db.QueryRowContext(ctx, updateList, arg.ID, arg.Title)
	var i List
	err := row.Scan(&i.ID, &i.Title, &i.DateCreate)
	return i, err
}
